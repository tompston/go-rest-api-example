// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: transaction.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const transaction_CountAll = `-- name: Transaction_CountAll :one
SELECT      COUNT(*)
FROM        transactions
`

func (q *Queries) Transaction_CountAll(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, transaction_CountAll)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const transaction_Create = `-- name: Transaction_Create :one
INSERT INTO transactions (  sender_id, receiver_id, amount )
VALUES      ( $1, $2, $3 )
RETURNING   transaction_id, created_at, updated_at, sender_id, receiver_id, amount
`

type Transaction_CreateParams struct {
	SenderID   uuid.UUID `json:"sender_id"`
	ReceiverID uuid.UUID `json:"receiver_id"`
	Amount     int32     `json:"amount"`
}

func (q *Queries) Transaction_Create(ctx context.Context, arg Transaction_CreateParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, transaction_Create, arg.SenderID, arg.ReceiverID, arg.Amount)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SenderID,
		&i.ReceiverID,
		&i.Amount,
	)
	return i, err
}

const transaction_DeleteWhereIdEquals = `-- name: Transaction_DeleteWhereIdEquals :one
DELETE FROM transactions
WHERE       transaction_id = $1
RETURNING   transaction_id, created_at, updated_at, sender_id, receiver_id, amount
`

func (q *Queries) Transaction_DeleteWhereIdEquals(ctx context.Context, transactionID uuid.UUID) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, transaction_DeleteWhereIdEquals, transactionID)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SenderID,
		&i.ReceiverID,
		&i.Amount,
	)
	return i, err
}

const transaction_GetAll = `-- name: Transaction_GetAll :many
SELECT      transaction_id, created_at, sender_id, receiver_id
FROM        transactions
ORDER BY    created_at DESC
`

type Transaction_GetAllRow struct {
	TransactionID uuid.UUID `json:"transaction_id"`
	CreatedAt     time.Time `json:"created_at"`
	SenderID      uuid.UUID `json:"sender_id"`
	ReceiverID    uuid.UUID `json:"receiver_id"`
}

func (q *Queries) Transaction_GetAll(ctx context.Context) ([]Transaction_GetAllRow, error) {
	rows, err := q.db.QueryContext(ctx, transaction_GetAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction_GetAllRow
	for rows.Next() {
		var i Transaction_GetAllRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.CreatedAt,
			&i.SenderID,
			&i.ReceiverID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transaction_GetAllBetweenDates = `-- name: Transaction_GetAllBetweenDates :many
SELECT      transaction_id, created_at,  sender_id, receiver_id, amount
FROM        transactions
WHERE       created_at BETWEEN SYMMETRIC $1 AND $2
ORDER BY    created_at DESC
`

type Transaction_GetAllBetweenDatesParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type Transaction_GetAllBetweenDatesRow struct {
	TransactionID uuid.UUID `json:"transaction_id"`
	CreatedAt     time.Time `json:"created_at"`
	SenderID      uuid.UUID `json:"sender_id"`
	ReceiverID    uuid.UUID `json:"receiver_id"`
	Amount        int32     `json:"amount"`
}

func (q *Queries) Transaction_GetAllBetweenDates(ctx context.Context, arg Transaction_GetAllBetweenDatesParams) ([]Transaction_GetAllBetweenDatesRow, error) {
	rows, err := q.db.QueryContext(ctx, transaction_GetAllBetweenDates, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction_GetAllBetweenDatesRow
	for rows.Next() {
		var i Transaction_GetAllBetweenDatesRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.CreatedAt,
			&i.SenderID,
			&i.ReceiverID,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transaction_GetAllWhereReceiverId = `-- name: Transaction_GetAllWhereReceiverId :many
SELECT      transaction_id, created_at,  sender_id, receiver_id, amount
FROM        transactions
WHERE       receiver_id = $1
ORDER BY    created_at DESC
`

type Transaction_GetAllWhereReceiverIdRow struct {
	TransactionID uuid.UUID `json:"transaction_id"`
	CreatedAt     time.Time `json:"created_at"`
	SenderID      uuid.UUID `json:"sender_id"`
	ReceiverID    uuid.UUID `json:"receiver_id"`
	Amount        int32     `json:"amount"`
}

func (q *Queries) Transaction_GetAllWhereReceiverId(ctx context.Context, receiverID uuid.UUID) ([]Transaction_GetAllWhereReceiverIdRow, error) {
	rows, err := q.db.QueryContext(ctx, transaction_GetAllWhereReceiverId, receiverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction_GetAllWhereReceiverIdRow
	for rows.Next() {
		var i Transaction_GetAllWhereReceiverIdRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.CreatedAt,
			&i.SenderID,
			&i.ReceiverID,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transaction_GetAllWhereSenderId = `-- name: Transaction_GetAllWhereSenderId :many
SELECT      transaction_id, created_at,  sender_id, receiver_id, amount
FROM        transactions
WHERE       sender_id = $1
ORDER BY    created_at DESC
`

type Transaction_GetAllWhereSenderIdRow struct {
	TransactionID uuid.UUID `json:"transaction_id"`
	CreatedAt     time.Time `json:"created_at"`
	SenderID      uuid.UUID `json:"sender_id"`
	ReceiverID    uuid.UUID `json:"receiver_id"`
	Amount        int32     `json:"amount"`
}

func (q *Queries) Transaction_GetAllWhereSenderId(ctx context.Context, senderID uuid.UUID) ([]Transaction_GetAllWhereSenderIdRow, error) {
	rows, err := q.db.QueryContext(ctx, transaction_GetAllWhereSenderId, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction_GetAllWhereSenderIdRow
	for rows.Next() {
		var i Transaction_GetAllWhereSenderIdRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.CreatedAt,
			&i.SenderID,
			&i.ReceiverID,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transaction_GetAllWithPaginationFirstPage = `-- name: Transaction_GetAllWithPaginationFirstPage :many
SELECT      transaction_id, created_at,  sender_id, receiver_id
FROM        transactions
ORDER BY    created_at DESC
LIMIT       $1
`

type Transaction_GetAllWithPaginationFirstPageRow struct {
	TransactionID uuid.UUID `json:"transaction_id"`
	CreatedAt     time.Time `json:"created_at"`
	SenderID      uuid.UUID `json:"sender_id"`
	ReceiverID    uuid.UUID `json:"receiver_id"`
}

func (q *Queries) Transaction_GetAllWithPaginationFirstPage(ctx context.Context, limit int32) ([]Transaction_GetAllWithPaginationFirstPageRow, error) {
	rows, err := q.db.QueryContext(ctx, transaction_GetAllWithPaginationFirstPage, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction_GetAllWithPaginationFirstPageRow
	for rows.Next() {
		var i Transaction_GetAllWithPaginationFirstPageRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.CreatedAt,
			&i.SenderID,
			&i.ReceiverID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transaction_GetAllWithPaginationNextPage = `-- name: Transaction_GetAllWithPaginationNextPage :many
SELECT      transaction_id, created_at,  sender_id, receiver_id
FROM        transactions
WHERE
    (
      created_at <= $1::TIMESTAMP
      OR 
      ( created_at = $1::TIMESTAMP AND transaction_id < $2::uuid )
    )
ORDER BY    created_at DESC
LIMIT       $3::int
`

type Transaction_GetAllWithPaginationNextPageParams struct {
	CreatedAt     time.Time `json:"created_at"`
	TransactionID uuid.UUID `json:"transaction_id"`
	Limit         int32     `json:"_limit"`
}

type Transaction_GetAllWithPaginationNextPageRow struct {
	TransactionID uuid.UUID `json:"transaction_id"`
	CreatedAt     time.Time `json:"created_at"`
	SenderID      uuid.UUID `json:"sender_id"`
	ReceiverID    uuid.UUID `json:"receiver_id"`
}

func (q *Queries) Transaction_GetAllWithPaginationNextPage(ctx context.Context, arg Transaction_GetAllWithPaginationNextPageParams) ([]Transaction_GetAllWithPaginationNextPageRow, error) {
	rows, err := q.db.QueryContext(ctx, transaction_GetAllWithPaginationNextPage, arg.CreatedAt, arg.TransactionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction_GetAllWithPaginationNextPageRow
	for rows.Next() {
		var i Transaction_GetAllWithPaginationNextPageRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.CreatedAt,
			&i.SenderID,
			&i.ReceiverID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transaction_GetWhereIdEquals = `-- name: Transaction_GetWhereIdEquals :one
SELECT      transaction_id, created_at,  sender_id, receiver_id, amount
FROM        transactions
WHERE       transaction_id = $1
LIMIT 1
`

type Transaction_GetWhereIdEqualsRow struct {
	TransactionID uuid.UUID `json:"transaction_id"`
	CreatedAt     time.Time `json:"created_at"`
	SenderID      uuid.UUID `json:"sender_id"`
	ReceiverID    uuid.UUID `json:"receiver_id"`
	Amount        int32     `json:"amount"`
}

func (q *Queries) Transaction_GetWhereIdEquals(ctx context.Context, transactionID uuid.UUID) (Transaction_GetWhereIdEqualsRow, error) {
	row := q.db.QueryRowContext(ctx, transaction_GetWhereIdEquals, transactionID)
	var i Transaction_GetWhereIdEqualsRow
	err := row.Scan(
		&i.TransactionID,
		&i.CreatedAt,
		&i.SenderID,
		&i.ReceiverID,
		&i.Amount,
	)
	return i, err
}
